有多种库如Spring MVC, Jersey用于处理Web请求，利用反射和注解，能方便的将用户的请求参数和内容转换为Java对象，
将Java对象转变为响应内容

有多种库如Spring, Guice利用这些特性实现了对象管理容器，方便程序员管理对象的生命周期以及其中复杂的依赖关系

应用服务器比如Tomcat利用类加载器实现不同应用之间的隔离、JSP技术也利用类加载器实现修改代码不用重启就能生效的特性

面向方面的编程(AOP - Aspect Oriented Programming)将编程中通用的关注点比如日志记录、安全检查等与业务的主体逻辑相分离，
减少冗余代码，提高程序的可维护性，AOP需要依赖上面的这些特性来实现

反射不一样，它是在运行时，而非编译时，动态获取类型的信息，比如接口信息、成员信息、
方法信息、构造方法信息等，根据这些动态获取到的信息创建对象、访问/修改成员、调用方法等。

"Class"类
获取Class对象
类和继承的基本实现原理，我们提到，每个已加载的类在内存都有一份类信息，
每个对象都有指向它所属类信息的引用。Java中，类信息对应的类就是java.lang.Class，
注意不是小写的class，class是定义类的关键字，所有类的根父类Object有一个方法，
可以获取对象的Class对象：
public final native Class<?> getClass()

字段(实例和静态变量)信息
类中定义的静态和实例变量都被称为字段，用类Field表示，位于包java.util.reflect下，
后文涉及到的反射相关的类都位于该包下

方法信息
类中定义的静态和实例方法都被称为方法，用类Method表示，Class有四个获取方法信息的方法：

很多利用反射的库和框架都默认假定类有无参public构造方法，
所以当类利用这些库和框架时要记住提供一个。

类Constructor表示构造方法，通过它可以创建对象，方法为：

慎用反射
反射虽然是灵活的，但一般情况下，并不是我们优先建议的，主要原因是：
反射更容易出现运行时错误，使用显式的类和接口，编译器能帮我们做类型检查，减少错误，但使用反射，类型是运行时才知道的，编译器无能为力
反射的性能要低一些，在访问字段、调用方法前，反射先要查找对应的Field/Method，性能要慢一些

简单的说，如果能用接口实现同样的灵活性，就不要使用反射。

小结
本节介绍了Java中反射相关的主要类和方法，通过入口类Class，可以访问类的各种信息，
如字段、方法、构造方法、父类、接口、泛型信息等，也可以创建和操作对象，调用方法等，
利用这些方法，可以编写通用的、动态灵活的程序，
本节演示了一个简单的通用序列化/反序列化类SimpleMapper。
反射虽然是灵活通用的，但它更容易出现运行时错误，所以，能用接口代替的时候，应该尽量使用接口。